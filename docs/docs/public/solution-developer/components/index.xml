<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Project Drasi – Components</title>
    <link>https://project-drasi.github.io/solution-developer/components/</link>
    <description>Recent content in Components on Project Drasi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2023, Microsoft; all rights reserved.</copyright>
    
	  <atom:link href="https://project-drasi.github.io/solution-developer/components/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Solution-Developer: Sources</title>
      <link>https://project-drasi.github.io/solution-developer/components/sources/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://project-drasi.github.io/solution-developer/components/sources/</guid>
      <description>
        
        
        &lt;p&gt;Sources provide connectivity to the systems that Drasi can observe as sources of change. Sources perform three important functions within Drasi:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Process the change log/feed generated by the source system and push those changes to each &lt;a href=&#34;https://project-drasi.github.io/solution-developer/components/continuous-queries&#34;&gt;Continuous Query&lt;/a&gt; that uses that Source as input.&lt;/li&gt;
&lt;li&gt;Translate source change data into a consistent property graph data model so that subscribed Continuous Queries can use that data as if it where a graph of Nodes and Relations. For graph sources, such as Gremlin, no translation is necessary. But for non-graph sources, such as PostgreSQL and Kubernetes, the Source transforms the data (more detail is provided in the individual Sources sections below).&lt;/li&gt;
&lt;li&gt;Provide a way for Continuous Queries to query the source system at startup to initialize the state of the Continuous Query result.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
    &lt;img src=&#34;simple-end-to-end.png&#34;
         alt=&#34;End to End&#34; width=&#34;65%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Drasi currently provides Sources for the following source systems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#azure-cosmos-db-gremlin-api-source&#34;&gt;Azure Cosmos DB Gremlin API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#postgresql-source&#34;&gt;PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kubernetes-source&#34;&gt;Kubernetes&lt;/a&gt; (experimental)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;creation&#34;&gt;Creation&lt;/h2&gt;
&lt;p&gt;Sources can be creates and manages using the &lt;code&gt;drasi&lt;/code&gt; CLI tool.&lt;/p&gt;
&lt;p&gt;The easiest way to create a Source, and the way you will often create one as part of a broader software solution, is to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Collect credentials and endpoint addresses that provide access to the change log and query API of the source system you want to connect to.&lt;/li&gt;
&lt;li&gt;Create a YAML file containing the Source resource definition. This will include the configuration settings that enable the Source to connect to the source system. This file can be stored in your solution repo and versioned along with all the other solution code / resources.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;drasi apply&lt;/code&gt; to apply the Source resource definition to the Kubernetes cluster where your Drasi environment is deployed.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As soon as the Source is created it will start running, monitoring its source system for changes and pushing them to subscribed Continuous Queries.&lt;/p&gt;
&lt;p&gt;The definition for a Source has the following basic structure:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Source
name: &amp;lt;id&amp;gt;
spec:
  kind: &amp;lt;type&amp;gt;
  (source kind specific fields)...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following table describes these configuration settings:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;apiVersion&lt;/td&gt;
&lt;td&gt;Must have the value &lt;strong&gt;v1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kind&lt;/td&gt;
&lt;td&gt;Must have the value &lt;strong&gt;Source&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;id&lt;/strong&gt; of the Source. Must be unique within the scope of the Sources in the Drasi deployment. The  &lt;strong&gt;id&lt;/strong&gt; is used to identify the Source through the CLI/API and in a Continuous Query definitions to identify which Sources the Continuous Query subscribes to for change events.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spec.kind&lt;/td&gt;
&lt;td&gt;The type of Source to create, which defines the type of database or source system the Source connects to. Must be one of &lt;a href=&#34;#azure-cosmos-db-gremlin-api-source&#34;&gt;CosmosGremlin&lt;/a&gt;, &lt;a href=&#34;#postgresql-source&#34;&gt;PostgreSQL&lt;/a&gt; or &lt;a href=&#34;#kubernetes-source&#34;&gt;Kubernetes&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spec.*&lt;/td&gt;
&lt;td&gt;The configuration settings passed to the Source as name-value pairs. Properties differ depending on the Source type (&lt;strong&gt;spec.kind&lt;/strong&gt;). See the individual Source sections below for the properties required by each Source type.  Any of these properties can either be specified inline or reference a secret. eg.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;PostgreSQL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;user&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;my-user&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;password&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;Secret&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;pg-creds&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;key&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;password&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;|&lt;/p&gt;
&lt;p&gt;Once configured, to create a Source defined in a file called &lt;code&gt;source.yaml&lt;/code&gt;, you would run the command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi apply -f source.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can then use the standard &lt;code&gt;drasi&lt;/code&gt; commands to query the existence and status of the Source resource. For example, to see a list of the active Sources, run the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi list source
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;deletion&#34;&gt;Deletion&lt;/h2&gt;
&lt;p&gt;To delete an active Source, run the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi delete source &amp;lt;id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example, if the Source ID is &lt;code&gt;human-resources&lt;/code&gt;, you would run,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi delete source human-resources
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Drasi does not currently enforce dependency integrity between Sources and Continuous Queries. If you delete a Source that is used by one or more Continuous Queries, they will stop getting change events and stop producing results.&lt;/p&gt;
&lt;h2 id=&#34;configuring-sources&#34;&gt;Configuring Sources&lt;/h2&gt;
&lt;p&gt;The following sections describe the configuration of the Source types currently supported by Drasi.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#azure-cosmos-db-gremlin-api-source&#34;&gt;Azure Cosmos DB Gremlin API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#postgresql-source&#34;&gt;PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kubernetes-source&#34;&gt;Kubernetes&lt;/a&gt; (experimental)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;azure-cosmos-db-gremlin-api-source&#34;&gt;Azure Cosmos DB Gremlin API Source&lt;/h3&gt;
&lt;p&gt;The Azure Cosmos DB Gremlin API Source enables Drasi connectivity to Azure Cosmos DB Gremlin API. It uses the Cosmos DB Change Log as the source of database change events, and calls the Gremlin API to retrieve data required to bootstrap Continuous Queries at creation.&lt;/p&gt;
&lt;h4 id=&#34;source-requirements&#34;&gt;Source Requirements&lt;/h4&gt;
&lt;p&gt;For the Cosmos DB Gremlin Source to function, you must ensure the Full Fidelity Change Feed support is enabled on the Cosmos Account you intend to use. Currently (as of 02/03/2023), this needs to be manually requested by &lt;a href=&#34;https://forms.office.com/pages/responsepage.aspx?id=v4j5cvGGr0GRqy180BHbR9ecQmQM5J5LlXYOPoIbyzdUOFVRNUlLUlpRV0dXMjFRNVFXMDNRRjVDNy4u&#34;&gt;filling out this form&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;configuration-settings&#34;&gt;Configuration Settings&lt;/h4&gt;
&lt;p&gt;The following is an example of a full resource definition for an Azure Cosmos DB Gremlin API Source using Kubernetes Secrets to securely store database credentials:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Source
name: retail-ops
spec:
  kind: CosmosGremlin
  accountEndpoint: 
    kind: Secret
    name: creds
    key: account-endpoint
  database: Contoso
  container: RetailOperations
  partitionKey: name
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Note: You could use the following command to easily create the seret referenced here:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl create secret generic creds --from-literal&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;account-endpoint&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the Source resource definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;apiVersion&lt;/strong&gt; must be &lt;strong&gt;v1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kind&lt;/strong&gt; must be &lt;strong&gt;Source&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt; is the &lt;strong&gt;id&lt;/strong&gt; of the Source and must be unique. This id is used in a Continuous Query definitions to identify which Sources the Continuous Query subscribes to for change events.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spec.kind&lt;/strong&gt; must be &lt;strong&gt;CosmosGremlin&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following table describes the Cosmos Gremlin specific properties that must be configured in the &lt;strong&gt;spec&lt;/strong&gt; object:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Property&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;accountEndpoint&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;PRIMARY&lt;/strong&gt; or &lt;strong&gt;SECONDARY CONNECTION STRING&lt;/strong&gt; from the &lt;strong&gt;Keys&lt;/strong&gt; page of the Azure Cosmsos DB Account page of the Azure Portal.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Database Id&lt;/strong&gt; from the Cosmos DB account.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;container&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Graph Id&lt;/strong&gt; from the Cosmos DB Database.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partitionKey&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;Partition Key&lt;/strong&gt; configured on the &lt;strong&gt;Graph&lt;/strong&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;data-transformation&#34;&gt;Data Transformation&lt;/h4&gt;
&lt;p&gt;Cosmos DB Gremlin already uses a property graph data model and so the Source does not need to do any data transformation as it processes the inbound changes. The only thing to note is the terminology differences between Gremlin and Drasi summarized in this table:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Gremlin Name&lt;/th&gt;
&lt;th&gt;Drasi Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Vertex&lt;/td&gt;
&lt;td&gt;Node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Edge&lt;/td&gt;
&lt;td&gt;Relation&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;postgresql-source&#34;&gt;PostgreSQL Source&lt;/h3&gt;
&lt;p&gt;The PostgreSQL Source enables Drasi connectivity to PostgreSQL databases. It uses the PostgreSQL replication log as the source of database change events, and calls the SQL API to retrieve data required to bootstrap Continuous Queries at creation.&lt;/p&gt;
&lt;h4 id=&#34;source-requirements-1&#34;&gt;Source Requirements&lt;/h4&gt;
&lt;p&gt;Your PostgreSQL database must be running at least version 10 and have &lt;code&gt;LOGICAL&lt;/code&gt; replication enabled. See the notes on &lt;a href=&#34;https://project-drasi.github.io/reference/postgresql-replication&#34;&gt;configuring PostgreSQL replication&lt;/a&gt; for assistance.&lt;/p&gt;
&lt;p&gt;You also need a PostgreSQL user that has at least the LOGIN, REPLICATION and CREATE permissions on the database and SELECT permissions on the tables you are interested in.&lt;/p&gt;
&lt;h4 id=&#34;configuration-settings-1&#34;&gt;Configuration Settings&lt;/h4&gt;
&lt;p&gt;The following is an example of a full resource definition for a PostgreSQL Source using Kubernetes Secrets to securely store database credentials:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl create secret generic pg-creds --from-literal&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#111&#34;&gt;password&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;my-password
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Source
name: phys-ops
spec:
  kind: PostgreSQL
  host: reactive-graph.postgres.database.azure.com
  port: 5432
  user: postgres@reactive-graph
  password:
    kind: Secret
    name: creds
    key: password
  database: phys-ops
  ssl: true
  tables:
    - public.Vehicle
    - public.Zone
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the Source resource definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;apiVersion&lt;/strong&gt; must be &lt;strong&gt;v1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kind&lt;/strong&gt; must be &lt;strong&gt;Source&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt; is the &lt;strong&gt;id&lt;/strong&gt; of the Source and must be unique. This id is used in a Continuous Query definitions to identify which Sources the Continuous Query subscribes to for change events.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spec.kind&lt;/strong&gt; must be &lt;strong&gt;PostgreSQL&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following table describes the PostgrSQL specific properties that must be configured in the &lt;strong&gt;spec&lt;/strong&gt; object:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Property&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;host name&lt;/strong&gt; of the PostgreSQL database server.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;port&lt;/strong&gt; number used to communicate with the PostgreSQL database server.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;user id&lt;/strong&gt; to use for authentication against the PostgreSQL database server.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;password&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;password&lt;/strong&gt; for the user account specified in the &lt;strong&gt;user&lt;/strong&gt; property.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;The name of the PostgreSQL database.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ssl&lt;/td&gt;
&lt;td&gt;Does the server require a secure connection, valid values are &amp;ldquo;true&amp;rdquo; or &amp;ldquo;false&amp;rdquo;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tables&lt;/td&gt;
&lt;td&gt;An array of table names that the Source should process changes for. Tables must have a &lt;strong&gt;public.&lt;/strong&gt; prefix.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;data-transformation-1&#34;&gt;Data Transformation&lt;/h4&gt;
&lt;p&gt;The PostgreSQL Source translates the relational data from change events to more closely resemble property graph data change events so that they can be processed by subscribed Continuous Queries. To achieve this, the PostgreSQL Source represents table rows as graph Nodes, as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each row gets represented as a Node with the table columns as properties of the Node.&lt;/li&gt;
&lt;li&gt;The Node is assigned an id the is a composite of the table id and the row&amp;rsquo;s primary key. This is Node metadata, not a property of the Node.&lt;/li&gt;
&lt;li&gt;The name of the table is assigned as a &lt;strong&gt;Label&lt;/strong&gt; of the Node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The PostgreSQL Source &lt;strong&gt;does not&lt;/strong&gt; interpret foreign keys or joins from the relational source, instead relying on the Source Join feature provided by Continuous Queries to mimic graph-style Relations between Nodes based on the values of specified properties. See the &lt;a href=&#34;https://project-drasi.github.io/solution-developer/components/continuous-queries/#source-subscriptions&#34;&gt;Source Joins&lt;/a&gt; topic in the &lt;a href=&#34;https://project-drasi.github.io/solution-developer/components/continuous-queries&#34;&gt;Continuous Queries&lt;/a&gt; section for details.&lt;/p&gt;
&lt;h3 id=&#34;kubernetes-source&#34;&gt;Kubernetes Source&lt;/h3&gt;
&lt;p&gt;The Kubernetes Source is an early stage experimental Source that enables Drasi connectivity to Kubernetes clusters, enabling Drasi to support Continuous Queries that incorporate changes to Kubernetes resources.&lt;/p&gt;
&lt;h4 id=&#34;source-requirements-2&#34;&gt;Source Requirements&lt;/h4&gt;
&lt;p&gt;You will need a client side credentials that can be used to authenticate against your Kubernetes cluster and has permission to watch resources.&lt;/p&gt;
&lt;h4 id=&#34;configuration-settings-2&#34;&gt;Configuration Settings&lt;/h4&gt;
&lt;p&gt;The following is an example of a full resource definition for a Kubernetes Source using Kubernetes Secrets to securely store credentials:&lt;/p&gt;
&lt;p&gt;To get the credentials, export the Kubernetes credentials to a file named &lt;code&gt;credentials.yaml&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For self hosted clusters, you can find this in your &lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/&#34;&gt;kubeconfig&lt;/a&gt; file&lt;/li&gt;
&lt;li&gt;For AKS, you can use this command&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;az aks get-credentials --resource-group &amp;lt;resource group&amp;gt; --name &amp;lt;cluster name&amp;gt; --file credentials.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Create a secret named &lt;code&gt;k8s-context&lt;/code&gt; from the &lt;code&gt;credentials.yaml&lt;/code&gt; file&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl create secret generic k8s-context --from-file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;credentials.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Source
name: k8s
spec:
  kind: Kubernetes
  kubeconfig:
    kind: Secret
    name: k8s-context
    key: credentials.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the Source resource definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;apiVersion&lt;/strong&gt; must be &lt;strong&gt;v1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kind&lt;/strong&gt; must be &lt;strong&gt;Source&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt; is the &lt;strong&gt;id&lt;/strong&gt; of the Source and must be unique. This id is used in a Continuous Query definitions to identify which Sources the Continuous Query subscribes to for change events.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spec.kind&lt;/strong&gt; must be &lt;strong&gt;Kubernetes&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following table describes the properties that must be configured in the &lt;strong&gt;spec&lt;/strong&gt; object:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Property&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;kubeconfig&lt;/td&gt;
&lt;td&gt;A &lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig&#34;&gt;kubeconfig&lt;/a&gt; containing the credentials to connect to your cluster&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;data-transformation-2&#34;&gt;Data Transformation&lt;/h4&gt;
&lt;p&gt;Currently, only Pods and Containers are projected onto a graph schema.  The relation between them is labeled &lt;code&gt;HOSTS&lt;/code&gt; and flows from the &lt;code&gt;Pod&lt;/code&gt; to the &lt;code&gt;Container&lt;/code&gt;.  A MATCH cypher clause that connects these would look as follows&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-cypher&#34; data-lang=&#34;cypher&#34;&gt;MATCH (p:Pod)-[:HOSTS]-&amp;gt;(c:Container) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following properties are projected to the graph nodes&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Node Label&lt;/th&gt;
&lt;th&gt;Property&lt;/th&gt;
&lt;th&gt;Origin&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].image&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;started&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].started&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;ready&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].ready&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;restartCount&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].restartCount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].state&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].state.message&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;reason&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].state.reason&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;terminationMessage&lt;/td&gt;
&lt;td&gt;Pod.status.containerStatuses[].lastState.terminated.message&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;Pod.metadata.name&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;td&gt;podIP&lt;/td&gt;
&lt;td&gt;Pod.status.podIP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;td&gt;phase&lt;/td&gt;
&lt;td&gt;Pod.status.phase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;Pod.status.message&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;td&gt;hostIP&lt;/td&gt;
&lt;td&gt;Pod.status.hostIP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod&lt;/td&gt;
&lt;td&gt;reason&lt;/td&gt;
&lt;td&gt;Pod.status.reason&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Solution-Developer: Continuous Queries</title>
      <link>https://project-drasi.github.io/solution-developer/components/continuous-queries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://project-drasi.github.io/solution-developer/components/continuous-queries/</guid>
      <description>
        
        
        &lt;p&gt;Continuous Queries are the most important component of Drasi. They are the mechanism by which you tell Drasi what changes to detect in source systems as well as the data you want distributed when changes are detected. &lt;a href=&#34;https://project-drasi.github.io/solution-developer/components/sources&#34;&gt;Sources&lt;/a&gt; provide source changes to subscribed Continuous Queries, which then provide query result changes to subscribed &lt;a href=&#34;https://project-drasi.github.io/solution-developer/components/reactions&#34;&gt;Reactions&lt;/a&gt;.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;simple-end-to-end.png&#34;
         alt=&#34;End to End&#34; width=&#34;65%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Continuous Queries, as the name implies, are queries that run continuously. To understand what is unique about them, it is useful to contrast them with a the kind of &lt;strong&gt;instantaneous queries&lt;/strong&gt; developers are accustomed to running against databases.&lt;/p&gt;
&lt;p&gt;When you execute an &lt;strong&gt;instantaneous query&lt;/strong&gt;, you are running the query against the database at a point in time. The database calculates the results to the query and returns them. While you work with those results, you are working with a static snapshot of the data and are unaware of any changes that may have happened to the data after you ran the query. If you run the same instantaneous query periodically, the query results might be different each time due to changes made to the data by other processes. But to understand what has changed, you would need to compare the most recent result with the previous result.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;instantaneous-query.png&#34;
         alt=&#34;Instantaneous Query&#34; width=&#34;60%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Continuous Queries&lt;/strong&gt;, once started, continue to run until they are stopped. While running, Continuous Queries maintain a perpetually accurate query result, incorporating any changes made to the source database as they occur. Not only do Continuous Queries allow you to request the query result as it was at any point in time, but as changes occur, the Continuous Query determines exactly which result elements have been added, updated, and deleted, and distributes a precise description of the changes to all Reactions that have subscribed to the Continuous Query.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://project-drasi.github.io/continuous-query.png&#34;
         alt=&#34;Continuous Query&#34; width=&#34;60%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;Continuous Queries are implemented as graph queries written in the &lt;a href=&#34;https://project-drasi.github.io/solution-developer/query-language&#34;&gt;Cypher Query Language&lt;/a&gt;. The use of a declarative graph query language means you can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;describe in a single query expression which changes you are interested in detecting and what data you want notifications of those changes to contain.&lt;/li&gt;
&lt;li&gt;express rich query logic that takes into consideration both the properties of the data you are querying and the relationships between data.&lt;/li&gt;
&lt;li&gt;create queries that span data across multiple Sources without complex join syntax, even when there is no natural connection between data in the Source systems, including queries that incorporate both relational and graph sources.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;example-incident-alerts&#34;&gt;Example: Incident Alerts&lt;/h2&gt;
&lt;p&gt;Imagine an Incident Alerting Service which notifies managers if any of the employees in their team are at risk due to dangerous incidents happening in their location (e.g. fires, storms, protests, etc). For this example, assume the source data is a property graph of nodes (rectangles) and relations (lines) shown in the following diagram:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;incident-alerting-graph.png&#34; alt=&#34;Incident Alerting&#34;&gt;&lt;/p&gt;
&lt;p&gt;Using Drasi, the following Cypher query could be used to to identify each employee at risk:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MATCH
  (e:Employee)-[:ASSIGNED_TO]-&amp;gt;(t:Team),
  (m:Employee)-[:MANAGES]-&amp;gt;(t:Team),
  (e:Employee)-[:LOCATED_IN]-&amp;gt;(:Building)-[:LOCATED_IN]-&amp;gt;(r:Region),
  (i:Incident {type:&amp;#39;environmental&amp;#39;})-[:OCCURS_IN]-&amp;gt;(r:Region) 
WHERE
  elementId(e) &amp;lt;&amp;gt; elementId(m) AND i.severity IN [‘critical’, ‘extreme’] AND i.endTimeMs IS NULL
RETURN 
  m.name AS ManagerName, m.email AS ManagerEmail, 
  e.name AS EmployeeName, e.email AS EmployeeEmail,
  r.name AS RegionName, 
  elementId(i) AS IncidentId, i.severity AS IncidentSeverity, i.description AS IncidentDescription
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;MATCH&lt;/code&gt; and &lt;code&gt;WHERE&lt;/code&gt; clauses of the query describe a pattern that identifies all &lt;strong&gt;Employees&lt;/strong&gt; located in &lt;strong&gt;Buildings&lt;/strong&gt; within &lt;strong&gt;Regions&lt;/strong&gt; where there are active &lt;strong&gt;Incidents&lt;/strong&gt; of &lt;strong&gt;type&lt;/strong&gt; &amp;rsquo;environmental&amp;rsquo; that have a &lt;strong&gt;severity&lt;/strong&gt; level of ‘critical’ or ‘extreme’. This means that any combination of correctly connected nodes with the required property values should be included in the query result.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;RETURN&lt;/code&gt; clause of the query generates output containing the name and email address of the at risk employee and their manager, as well as details about the incident and the region in which it is located. This defines the schema for results generated by the Continuous Query.&lt;/p&gt;
&lt;p&gt;When the above Continuous Query is first run, there are no results that satisfy the query, because there are no Incidents in the data. But as soon as an extreme severity Forest Fire &lt;strong&gt;Incident&lt;/strong&gt; in Southern California is added to the database, as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;incident-alerting-graph-with-incident.png&#34; alt=&#34;Incident Added&#34;&gt;&lt;/p&gt;
&lt;p&gt;The query would generate the following output showing that two records (for employees &lt;strong&gt;Bob&lt;/strong&gt; and &lt;strong&gt;Claire&lt;/strong&gt;) now meet the query criteria and have been &lt;strong&gt;added&lt;/strong&gt; to the query result:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
 “added”: [
  { “ManagerName”: “Allen”, “ManagerEmail”: “allen@contoso.com”, “EmployeeName”: “Bob”, “EmployeeEmail”: “bob@contoso.com”, “RegionName”: “Southern California”, “IncidentId”: “in1000”, “IncidentSeverity”: “extreme”, “IncidentDescription”: “Forest Fire” },
  { “ManagerName”: “Allen”, “ManagerEmail”: “allen@contoso.com”, “EmployeeName”: “Claire”, “EmployeeEmail”: “claire@contoso.com”, “RegionName”: “Southern California”, “IncidentId”: “in1000”, “IncidentSeverity”: “extreme”, “IncidentDescription”: “Forest Fire” }
 ],
 “updated”: [],
 “deleted”: []
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;strong&gt;Bob&lt;/strong&gt; subsequently changed location, removing him from the Southern Californian Region while the Forest Fire was still active, the Continuous Query would generate the following output, showing that Bob’s record had been &lt;strong&gt;deleted&lt;/strong&gt; from the query result:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
 “added”: [],
 “updated”: [],
 “deleted”: [
  { “ManagerName”: “Allen”, “ManagerEmail”: “allen@contoso.com”, “EmployeeName”: “Bob”, “EmployeeEmail”: “bob@contoso.com”, “RegionName”: “Southern California”, “IncidentId”: “in1000”, “IncidentSeverity”: “extreme”, “IncidentDescription”: “Forest Fire” }
 ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If the &lt;strong&gt;severity&lt;/strong&gt; of the Forest Fire then changed from &amp;rsquo;extreme&amp;rsquo; to &amp;lsquo;critical&amp;rsquo;, the Continuous Query would spontaneously generate the following output showing a that the result for Claire had been &lt;strong&gt;updated&lt;/strong&gt;. The update includes what the result was both &lt;strong&gt;before&lt;/strong&gt; and &lt;strong&gt;after&lt;/strong&gt; the change:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
 “added”: [],
 “updated”: [
  { 
   “before”: { “ManagerName”: “Allen”, “ManagerEmail”: “allen@contoso.com”, “EmployeeName”: “Bob”, “EmployeeEmail”: “bob@contoso.com”, “RegionName”: “Southern California”, “IncidentId”: “in1000”, “IncidentSeverity”: “extreme”, “IncidentDescription”: “Forest Fire” },
   “after”: { “ManagerName”: “Allen”, “ManagerEmail”: “allen@contoso.com”, “EmployeeName”: “Bob”, “EmployeeEmail”: “bob@contoso.com”, “RegionName”: “Southern California”, “IncidentId”: “in1000”, “IncidentSeverity”: “critical”, “IncidentDescription”: “Forest Fire” }
 ],
 “deleted”: []
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In some instances, a single source change can result in multiple changes to the query result e.g. multiple records can be added, updated, and deleted. In such cases, the Continuous Query generates a single result change notification containing all the changes. This enables subscribed Reactions to treat the related changes atomically given they all arose from a single source change.&lt;/p&gt;
&lt;h2 id=&#34;creation&#34;&gt;Creation&lt;/h2&gt;
&lt;p&gt;Continuous Queries can be created and managed using the &lt;code&gt;drasi&lt;/code&gt; CLI tool.&lt;/p&gt;
&lt;p&gt;The easiest way to create a Continuous Query, and the way you will often create one as part of a broader software solution, is to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a YAML file containing the Continuous Query definition. This can be stored in your solution repo and versioned along with all the other solution code / resources.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;drasi apply&lt;/code&gt; to apply the YAML file, creating the Continuous Query&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When a new Continuous Query is created it:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Subscribes to its Sources, describing the types of change it wants to receive.&lt;/li&gt;
&lt;li&gt;Queries its Sources to load the initial data for its query result.&lt;/li&gt;
&lt;li&gt;Begins processing the stream of SourceChangeEvents from its Sources that represent the sequence of low-level database changes that have occurred (inserts, updated, deletes) and translates them into changes to its query result.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here is a simple example of the definition for the Incident Alerting Continuous Query used in the example above:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: ContinuousQuery
name: manager-incident-alert
spec:
  sources:    
    subscriptions:
      - id: human-resources
  query: &amp;gt; 
    MATCH
      (e:Employee)-[:ASSIGNED_TO]-&amp;gt;(t:Team),
      (m:Employee)-[:MANAGES]-&amp;gt;(t:Team),
      (e:Employee)-[:LOCATED_IN]-&amp;gt;(:Building)-[:LOCATED_IN]-&amp;gt;(r:Region),
      (i:Incident {type:&amp;#39;environmental&amp;#39;})-[:OCCURS_IN]-&amp;gt;(r:Region) 
    WHERE
      elementId(e) &amp;lt;&amp;gt; elementId(m) AND i.severity IN [‘critical’, ‘extreme’] AND i.endTimeMs IS NULL
    RETURN 
      m.name AS ManagerName, m.email AS ManagerEmail, 
      e.name AS EmployeeName, e.email AS EmployeeEmail,
      r.name AS RegionName, 
      elementId(i) AS IncidentId, i.severity AS IncidentSeverity, i.description AS IncidentDescription
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example, the &lt;code&gt;spec.sources.subscriptions&lt;/code&gt; property identifies the Source with the id &lt;code&gt;human-resources&lt;/code&gt; as the source of data for the Continuous Query. The &lt;code&gt;spec.query&lt;/code&gt; property contains the text of the Cypher query. Full details of the Continuous Query configuration options are described in the &lt;a href=&#34;#configuration&#34;&gt;Configuration&lt;/a&gt; section.&lt;/p&gt;
&lt;p&gt;If this Continuous Query resource definition was contained in a file called &lt;code&gt;query.yaml&lt;/code&gt;, to create this query on a Drasi environment that was the current Kubectl context, you would run the command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi apply -f query.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can then use additional &lt;code&gt;drasi&lt;/code&gt; commands to query the existence and status of the Continuous Query resource. For example, to see a list of the active Continuous Queries, run the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi list continuousqueries
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;deletion&#34;&gt;Deletion&lt;/h2&gt;
&lt;p&gt;To delete an active Continuous Query, run the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi delete continuousqueries &amp;lt;query-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example, if the Continuous Query id from the &lt;code&gt;name&lt;/code&gt; property of the resource definition is &lt;code&gt;manager-incident-alert&lt;/code&gt;, you would run,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi delete continuousqueries manager-incident-alert
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Drasi does not currently enforce dependency integrity between Continuous Queries and Reactions. If you delete a Continuous Query that is used by one or more Reactions, they will stop getting query result changes.&lt;/p&gt;
&lt;h2 id=&#34;configuration&#34;&gt;Configuration&lt;/h2&gt;
&lt;p&gt;The definition for a Continuous Query has the following basic structure:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: ContinuousQuery
name: &amp;lt;continuous_query_id&amp;gt;
spec:
  mode: &amp;lt;QUERY | filter&amp;gt;
  indexType: &amp;lt;PERSISTED | memory&amp;gt;
  sources:    
    subscriptions:
      - id: &amp;lt;source_1_id&amp;gt;
        nodes:
          - sourceLabel: &amp;lt;source_1_node_1_source_label&amp;gt;, 
            queryLabel: &amp;lt;source_1_node_1_query_label&amp;gt;,
            suppressIndex: &amp;lt;true | FALSE&amp;gt;
          - ...
        relations:
          - sourceLabel: &amp;lt;source_1_rel_1_source_label&amp;gt;, 
            queryLabel: &amp;lt;source_1_rel_1_query_label&amp;gt;,
            suppressIndex: &amp;lt;true | FALSE&amp;gt;
          - ...
      - id: &amp;lt;source_2_id&amp;gt;
        nodes: ...
        relations: ...
    joins:
      - id: &amp;lt;join_1_id&amp;gt;
        keys:
          - label: &amp;lt;key_1_label_name&amp;gt;
            property: &amp;lt;key_1_property_name&amp;gt;
          - label: &amp;lt;key_2_label_name&amp;gt;
            property: &amp;lt;key_2_property_name&amp;gt;
      - id: &amp;lt;join_2_id&amp;gt;
        keys: ...
  view:
    enabled: &amp;lt;true | false&amp;gt;
    retentionPolicy:
      &amp;lt;latest: | all: | expire: afterSeconds: &amp;lt;TTL&amp;gt;&amp;gt;
  params:
    &amp;lt;param_1_key&amp;gt;: &amp;lt;param_1_value&amp;gt;
    &amp;lt;param_2_key&amp;gt;: &amp;lt;param_2_value&amp;gt;
    ...
  query: MATCH ... WHERE ... RETURN ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the Continuous Query resource definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;apiVersion&lt;/strong&gt; must be &lt;strong&gt;v1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;kind&lt;/strong&gt; must be &lt;strong&gt;ContinuousQuery&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt; is the &lt;strong&gt;id&lt;/strong&gt; of the Continuous Query and must be unique. Is used to identify the Continuous Query through the CLI/API and in Reactions to identify the Continuous Queries they should subscribe to..&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following table provides a summary of the other configuration settings from the &lt;strong&gt;spec&lt;/strong&gt; section of the resource definition:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mode&lt;/td&gt;
&lt;td&gt;Can have the value &lt;strong&gt;query&lt;/strong&gt; (default) or &lt;strong&gt;filter&lt;/strong&gt;. If a Continuous Query is running in &lt;strong&gt;filter&lt;/strong&gt; mode, it does not maintain a query result and as such does not generate detailed change notifications in response to Source changes. Instead, any Source change that adds or updates a query result will be output as an &lt;strong&gt;added&lt;/strong&gt; result item. Any change that causes results to be removed from the query result will not generate output.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indexType&lt;/td&gt;
&lt;td&gt;Can have the value &lt;strong&gt;persisted&lt;/strong&gt; (default) or &lt;strong&gt;memory&lt;/strong&gt;. This settings controls whether Drasi caches the Continuous Query element and solution indexes to a persistent store, or keeps them in memory. Using memory-based indexes is good for testing and is also OK for Continuous Queries that do not require significant bootstrapping when they start.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sources&lt;/td&gt;
&lt;td&gt;Contains two sections: &lt;strong&gt;subscriptions&lt;/strong&gt; and &lt;strong&gt;joins&lt;/strong&gt;. The &lt;strong&gt;subscriptions&lt;/strong&gt; section describes the Sources the Continuous Query will subscribe to for data and optionally maps the Source Labels to the Label names used in the Cypher Query. The &lt;strong&gt;joins&lt;/strong&gt; section describes the way the Continuous Query connects elements from multiple sources to enable you to write graph queries that span sources. Both sections are described in more detail in the &lt;a href=&#34;#sources&#34;&gt;Sources&lt;/a&gt; section.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;params&lt;/td&gt;
&lt;td&gt;Parameter values that are used by the Cypher query, enabling the repeated use of the same query that can be customized using parameter values.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;view&lt;/td&gt;
&lt;td&gt;(Optional). Defines the behaviour of the results view.  &lt;strong&gt;enabled&lt;/strong&gt; controls if the results of the query are cached in the results view. &lt;strong&gt;retentionPolicy&lt;/strong&gt; determines how long the results will be stored for.  &lt;strong&gt;latest&lt;/strong&gt; (default) only holds the most recent version, &lt;strong&gt;all&lt;/strong&gt; holds all previous versions and allows querying at a time point in the past, &lt;strong&gt;expire&lt;/strong&gt; holds the non current results for a limited time.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;query&lt;/td&gt;
&lt;td&gt;The Cypher query that defines the change the Continuous Query is detecting and the output it generates. Explained in &lt;a href=&#34;https://project-drasi.github.io/solution-developer/query-language&#34;&gt;Continuous Query Syntax&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;sources&#34;&gt;Sources&lt;/h3&gt;
&lt;p&gt;The configuration settings in the &lt;strong&gt;spec.sources.subscriptions&lt;/strong&gt; section of the Continuous Query resource definition do the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define the Sources the Continuous Query will subscribe to for its change data.&lt;/li&gt;
&lt;li&gt;Within each Source, define the Labels of the Nodes and Relations that the the Continuous Query expects from that Source. If you do not map a Node/Relation Label used in the query to a specific Source, it is assumed to come from the first Source configured.&lt;/li&gt;
&lt;li&gt;For each Node and Relation, create a mapping between the Label name used in the Source data and the Label name used in the Query. This allows you to write queries independent of the Label/Type names used in the source data, easily use the same Query against multiple sources, and deal with the name collisions across Sources.&lt;/li&gt;
&lt;li&gt;For each Node and Relation, you also have the ability to disable element level caching. This can be useful when processing append only logs where the main element being processed (i.e. the log record) will never change once created, and will not be referenced in query future query results.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The configuration settings in the &lt;strong&gt;spec.sources.joins&lt;/strong&gt; section of the Continuous Query resource definition create a mapping between a Label and Property name pair from one source, with a Label and Property Name pair in another source.
This allows the Continuous Query to be written as a single unified query without consideration from which Source data is originating from. Drasi will use the mapping to create synthetic relations between Nodes as required.&lt;/p&gt;
&lt;p&gt;Here is an example of a Continuous Query from the &lt;a href=&#34;https://project-drasi.github.io/solution-developer/sample-apps/curbside-pickup/&#34;&gt;Curbside Pickup&lt;/a&gt; demo app that defines two Sources: &lt;strong&gt;phys-ops&lt;/strong&gt; and &lt;strong&gt;retail-ops&lt;/strong&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: ContinuousQuery
name: curbside-pickup
spec:
  mode: query
  indexType: persisted
  sources:    
    subscriptions:
      - id: phys-ops
        nodes:
          - sourceLabel: Vehicle
          - sourceLabel: Zone
        relations:
          - sourceLabel: LOCATED_IN
      - id: retail-ops
        nodes:
          - sourceLabel: Driver
          - sourceLabel: Order
          - sourceLabel: OrderPickup
        relations:
          - sourceLabel: PICKUP_DRIVER
          - sourceLabel: PICKUP_ORDER
    joins:
      - id: VEHICLE_TO_DRIVER
        keys:
          - label: Vehicle
            property: plate
          - label: Driver
            property: plate
  query: ...
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Solution-Developer: Reactions</title>
      <link>https://project-drasi.github.io/solution-developer/components/reactions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://project-drasi.github.io/solution-developer/components/reactions/</guid>
      <description>
        
        
        &lt;p&gt;Reactions process the stream of query result changes output by one or more Continuous Queries and act on them.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&#34;simple-end-to-end.png&#34;
         alt=&#34;End to End&#34; width=&#34;65%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;The action taken depends on the Reaction type being used. Drasi currently provides the following Reactions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#event-grid-reaction&#34;&gt;Azure Event Grid&lt;/a&gt;, to forward Continuous Query results to Azure Event Grid, which in turn enables integration with any application, service, or function that can receive updates from Azure Event Grid.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#debug-reaction&#34;&gt;Debug&lt;/a&gt;, a tool to help developers inspect the results generated by Continuous Queries.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#signalr-reaction&#34;&gt;SignalR&lt;/a&gt;, to forward Continuos Query results to Web Applications.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gremlin-reaction&#34;&gt;Gremlin&lt;/a&gt;, to use the Continuous Query results as parameters to commands that run against a Gremlin database.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;To create custom Reactions, see the &lt;a href=&#34;https://project-drasi.github.io/platform-developer/reactions/&#34;&gt;Custom Reactions&lt;/a&gt; section of the &lt;a href=&#34;https://project-drasi.github.io/platform-developer&#34;&gt;Platform Developer Guide&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;creation&#34;&gt;Creation&lt;/h2&gt;
&lt;p&gt;Reactions can be created and managed using the &lt;code&gt;drasi&lt;/code&gt; CLI tool.&lt;/p&gt;
&lt;p&gt;The easiest way to create a Reaction, and the way you will often create one as part of a broader software solution, is to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Collect ID&amp;rsquo;s of the Continuous Queries the Reaction will subscribe to.&lt;/li&gt;
&lt;li&gt;Collect credentials and endpoint addresses that provide access to any external system the Reaction interacts with.&lt;/li&gt;
&lt;li&gt;Create a YAML file containing the Reaction Resource Definition. This will include the configuration settings that enable the Reaction to connect to external systems. This can be stored in your solution repo and versioned along with all the other solution code / resources.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;drasi apply&lt;/code&gt; to apply the Reaction resource definition to the Kubernetes cluster where your Drasi environment is deployed.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As soon as the Reaction is created it will start running, subscribing to its Continuous Queries and processing query result changes.&lt;/p&gt;
&lt;p&gt;The definition for a Reaction has the following structure:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Reaction
name: &amp;lt;reaction-id&amp;gt;
spec:
  image: &amp;lt;reaction-image&amp;gt;
  queries:
    query1: &amp;lt;custom metadata for query1 (optional)&amp;gt;
    query2: &amp;lt;custom metadata for query2 (optional)&amp;gt;
  properties:
    &amp;lt;property_1_name&amp;gt;: &amp;lt;property_1_value&amp;gt;
    &amp;lt;property_2_name&amp;gt;: 
      kind: Secret
      name: &amp;lt;secret_id&amp;gt;
      key: &amp;lt;secret_key&amp;gt;          
  endpoints:
    &amp;lt;endpoint_name&amp;gt;: &amp;lt;enpoint_port_num&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following table provides a summary of these configuration settings:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;apiVersion&lt;/td&gt;
&lt;td&gt;Must have the value &lt;strong&gt;v1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kind&lt;/td&gt;
&lt;td&gt;Must have the value &lt;strong&gt;Reaction&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;The &lt;strong&gt;id&lt;/strong&gt; of the Reaction. Must be unique within the scope of the Reactions in the Drasi deployment. The  &lt;strong&gt;id&lt;/strong&gt; is used to manage the Reaction.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spec.image&lt;/td&gt;
&lt;td&gt;The name of the docker image for the Reaction.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spec.queries&lt;/td&gt;
&lt;td&gt;The list of Continuous Query IDs the Reaction will subscribe to. Some Reactions also need per-query configuration, which can be passed using the options property of the queryId. These are unique to the type of Reaction and are detailed in the sections below.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spec.properties&lt;/td&gt;
&lt;td&gt;Name/value pairs used to configure the Reaction. These are unique to the type of Reaction and are detailed in the sections below.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spec.endpoints&lt;/td&gt;
&lt;td&gt;Names and port numbers to use for Reactions that expose accessible ports for clients to connect to.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Once configured, to create a Reaction defined in a file called &lt;code&gt;reaction.yaml&lt;/code&gt;, you would run the command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi apply -f reaction.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can then use additional &lt;code&gt;drasi&lt;/code&gt; commands to query the existence and status of the Reaction resource. For example, to see a list of the active Reactions, run the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi list reaction
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;deletion&#34;&gt;Deletion&lt;/h2&gt;
&lt;p&gt;To delete an active Reaction, run the following command:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi delete reaction &amp;lt;reaction-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example, if the Reaction ID is &lt;code&gt;update-gremlin&lt;/code&gt;, you would run,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;drasi delete reaction update-gremlin
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;configuring-reactions&#34;&gt;Configuring Reactions&lt;/h2&gt;
&lt;p&gt;The following sections describe the configuration of the Reaction types currently supported by Drasi.&lt;/p&gt;
&lt;h3 id=&#34;azure-event-grid-reaction&#34;&gt;Azure Event Grid Reaction&lt;/h3&gt;
&lt;p&gt;The Event Grid Reaction requires the following configuration settings:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Must have the value &lt;strong&gt;reaction-eventgrid&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EventGridUri&lt;/td&gt;
&lt;td&gt;Property&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EventGridKey&lt;/td&gt;
&lt;td&gt;Property&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The following is an example of a fully configured Event Grid Reaction using Kubernetes Secrets to securely store sensitive information:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl create secret generic credentials --from-literal&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;access-key&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;xxxxxx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Reaction
name: eventgrid1
spec:
  image: reaction-eventgrid
  EventGridUri: https://reactive-graph-daniel.westus-1.eventgrid.azure.net/api/events
  EventGridKey: 
    kind: Secret
    name: credentials
    key: access-key      
  queries:
    my-query1:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;gremlin-reaction&#34;&gt;Gremlin Reaction&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id=&#34;signalr-reaction&#34;&gt;SignalR Reaction&lt;/h3&gt;
&lt;p&gt;The SignalR Reaction requires the following configuration settings:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Must have the value &lt;strong&gt;reaction-signalr&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AzureSignalRConnectionString&lt;/td&gt;
&lt;td&gt;Property&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gateway&lt;/td&gt;
&lt;td&gt;Endpoint&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The following is an example of a fully configured Event Grid Reaction using Kubernetes Secrets to securely store sensitive information:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl create secret generic credentials --from-literal&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;connection-string&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;xxxxxx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1
kind: Reaction
name: signalr1
spec:
  image: reaction-signalr
  AzureSignalRConnectionString:
    kind: Secret
    name: credentials
    key: connection-string          
  endpoints:
    gateway: 8080
  queries:
    my-query1:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;debug-reaction&#34;&gt;Debug Reaction&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
