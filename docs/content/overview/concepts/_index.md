---
type: "docs"
title: "Concepts"
linkTitle: "Concepts"
weight: 5
description: >
    Understanding Reactive Graph's Core Concepts
---

**The Reactive Graph Preview is a prototype and is only suitable for experimentation, not for production systems.**

Reactive Graph is built around three core concepts: [Sources](#sources), [Continuous Queries](#continuous-queries), and [Reactions](#reactions). 

 
# Sources
Sources provide connectivity to the systems that Reactive Graph can observe as sources of change. These would typically be either relational databases or graph databases in which the system of interest stores its data, but a Source could be implemented for any system that provides:

 a low-level change feed and a way to query the current state of the system. Reactive Graph’s input data schema is modeled on Debezium (https://debezium.io). Debezium is an open-source change data capture platform that has adapters for many common data sources. By embracing Debezium, Reactive Graph will be able to use many existing Debezium sources as input. Reactive Graph is in an early phase of incubation and currently provides Sources for Azure Cosmos Gremlin API, PostgreSQL, and Kubernetes. We’ll add additional Sources in the future.

 

# Continuous Queries
Continuous Queries process change events from one or more Sources and evaluate each change to determine if it affects the Continuous Query’s result. If so, the Continuous Query determines exactly which result elements have been added, updated, and deleted, uses them to update its current result, and dispatches them for distribution to consumers that have registered interest in the Continuous Query using a Reaction.

Continuous Queries can receive changes from multiple sources and use Cypher graph queries to integrate data across sources regardless of whether the source is a relational or graph database. 

 

# Reactions
Reactions are created by consumers to process the stream of query result updates generated by one or more Continuous Queries. Current Reaction implementations support forwarding query results to consumer apps and services via messaging infrastructure such as Azure Event Grid and Azure Event Hub. There is also a SignalR Reaction to enable Web applications to receive dynamic updates from Continuous Queries. But Reactions can be developed to do anything possible in code, including performing updates on the source systems and databases without the need to integrate with additional software services. We plan to explore Reactions embedded within the database system itself making them behave similar to stored procedures gaining even more efficiency over calling out to external services.

 

