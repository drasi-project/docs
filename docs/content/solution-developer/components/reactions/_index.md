---
type: "docs"
title: "Reactions"
linkTitle: "Reactions"
weight: 60
description: >
    What are Reactions and How to Use Them
---

Reactions process the stream of query result updates generated by one or more Continuous Queries and act on them.

 ![End to End](simple-end-to-end.png)

Drasi currently provides the following Reactions:

- [Azure Event Grid](#event-grid-reaction), to forward Continuous Query results to Azure Event Grid, which in turn enables integration with any application, service, or function that can receive updates from Azure Event Grid.
- [SignalR](#signalr-reaction), to forward Continuos Query results to Web Applications.
- [Gremlin](#gremlin-reaction), to use the Continuous Query results as parameters to commands that run against a Gremlin database.
- [SQL Stored Procedure](#sql-stored-procedure-reaction), to use the Continuous Query results as parameters to stored procedures that run on a SQL database.
- [Debug](#debug-reaction), a tool to help developers inspect the results generated by Continuous Queries.

*To create custom Reactions, see the [Platform Developer Guide](/platform-developer)*

## Creation
Reactions are custom Kubernetes resources that you can create and manage using `Kubectl`. 

The easiest way to create a Reaction, and the way you will often create one as part of a broader software solution, is to:

1. Collect ID's and credentials that provide access to the Continuous Queries the Reaction will subscribe to.
1. Collect credentials and endpoint addresses that provide access to any external system the Reaction interacts with.
1. Create a YAML file containing the Reaction Resource Definition. This will include the configuration settings that enable the Reaction to connect to external systems. This can be stored in your solution repo and versioned along with all the other solution code / resources.
1. Run Kubectl to apply the Reaction resource definition to the Kubernetes cluster where your Drasi environment is deployed.

As soon as the Reaction is created it will start running, subscribing to its Continuous Queries for changes.

The Kubernetes resource definition for a Reaction has the following structure:

```
apiVersion: query.reactive-graph.io/v1
kind: Reaction
metadata:
  name: (your reaction name)
spec:
  reactionImage: (your docker image)
  queries:
    - queryId: (a query you want to react to)
      options: >
        some custom metadata for your query (optional)
  properties:
    - name: (some env variable to be mounted)
      value: (value of env variable)
    - name: (some secret env variable to be mounted)
      valueFrom:
        secretKeyRef:
          name: (name of secret)
          key: (name of key)
  endpoints:
    - name: (name of a port you want to expose (optional))
      port: 8080
  daprAppPort: 80 (optional override, default = 80)
```
The following table provides a summary of these configuration settings:

|Name|Description|
|-|-|
|apiVersion|Must have the value **query.reactive-graph.io/v1**|
|kind|Must have the value **Reaction**|
|metadata.name|The **<source-id>** of the Source. Must be unique. Is used to manage the Source through Kubectl and in a Continuous Query definition to describe which Sources the Continuous Query uses as input.|
|spec.sourceType|The name of the type of Source to create. Must be one of **CosmosGremlin**, **PostgreSQL** or **Kubernetes**
|spec.properties|The configuration settings passed to the Source. Required settings differ depending on the Source implementation. See the individual Source sections below.|

If this Source resource definition was contained in a file called `source.yaml`, to create this query on a Drasi environment that was the current Kubectl context, you would run the command:

```
kubectl apply -f source.yaml
```

You can then use the standard Kubectl commands to query the existence and status of the Source resource. For example, to see a list of the active Sources, run the following command:

```
kubectl get sources
```


## Deletion
To delete an active Source, run the following command:

```
kubectl delete source <source-id>
```

For example, if the Source id is `human-resources`, you would run,

```
kubectl delete source human-resources
```



- A volume will be mounted at `/etc/queries` where each file will be the name of a query and the contents of each file will be custom metadata.
- All the key/value pairs from `properties` will be mounted as environment variables.  You can also reference secrets and config maps as you would normally do with environment variables.
- Any entries in `endpoints` will create a network service with the name `<reaction name>-<endpoint name>` and map to the container port specified in `port`
- The Dapr server within your reaction should listen on port 80, this can be overridden with `daprAppPort`
  
The **source-id** must be unique within the scope of the Drasi envionment, and is the ID used in a Continuous Query definition to describe which Sources the Continuous Query uses as input.


## Configuring Reactions
The following sections describe the configuration of the Reaction types currently supported by Drasi.

### Event Grid Reaction
The Event Grid Reaction requires the following configuration settings:

|Name|Type|Description|
|-|-|-|
|reactionImage| | Must have the value **reactive-graph/reaction-eventgrid**|
|EventGridUri| Property | |
|EventGridKey| Property | |

The following is an example of a fully configured Event Grid Reaction using Kubernetes Secrets to securely store sensitive information:

```
apiVersion: v1
kind: Secret
metadata:
  name: credentials
type: Opaque
stringData:
  access-key: xxxxxx
---
apiVersion: query.reactive-graph.io/v1
kind: Reaction
metadata:
  name: eventgrid1
spec:
  reactionImage: reactive-graph/reaction-eventgrid
  properties:
    - name: EventGridUri
      value: https://reactive-graph-daniel.westus-1.eventgrid.azure.net/api/events
    - name: EventGridKey
      valueFrom:
        secretKeyRef:
          name: credentials
          key: access-key
  queries:
    - queryId: my-query1
```

### SignalR Reaction
The SignalR Reaction requires the following configuration settings:

|Name|Type|Description|
|-|-|-|
|reactionImage| | Must have the value **reactive-graph/reaction-signalr**|
|AzureSignalRConnectionString| Property | |
|gateway| Endpoint | |

The following is an example of a fully configured Event Grid Reaction using Kubernetes Secrets to securely store sensitive information:

```
apiVersion: v1
kind: Secret
metadata:
  name: credentials
type: Opaque
stringData:
  connection-string: xxxxxx
---
apiVersion: query.reactive-graph.io/v1
kind: Reaction
metadata:
  name: signalr1
spec:
  reactionImage: reactive-graph/reaction-signalr
  properties:
    - name: AzureSignalRConnectionString
      valueFrom:
        secretKeyRef:
          name: credentials
          key: connection-string
  endpoints:
    - name: gateway
      port: 8080
  queries:
    - queryId: my-query1
```

### Gremlin Reaction
TODO

### SQL Stored Procedure Reaction
TODO

### Debug Reaction
TODO
