---
type: "docs"
title: "Architecture"
linkTitle: "Architecture"
weight: 20
description: >
    Overview of the Drasi Architecture
---


## Overview

The following diagram shows the end-to-end service-level architecture of Drasi.

 ![Platform Architecture](platform-architecture.png)

Drasi is deployed to a Kubernetes cluster as a Kubernetes operator which deploys and manages a set of custom resources. The custom resources shown in the diagram include:
-	Source (green), which provides bi-directional connectivity to data sources.
-	Query Container (blue), which hosts one or more Continuous Queries and provides the persistent store in which the Continuous Queries store their indexes.
-	Reaction (purple), which receives and processes Continuous Query result updates.

There can be multiple Sources, Query Containers, and Reactions configured in a Drasi installation.  Of note:
-	Individual services (depicted as small colored rectangles) are written in Node.js or C# and use dapr for service discovery and invocation, pubsub, and state management.
-	The Query Host is a dapr actor host and will host multiple Continuous Queries that are implemented as dapr actors.
-	The persistent index / result store in the Query Container is currently Mongo DB, but we are actively evaluating alternatives such as Garnet. 
-	The small grey boxes represent messaging infrastructure that is abstracted by dapr. Currently we use Kafka for messaging.
-	The Drasi Operator is written in Go.
-	Red dots indicate Auth boundaries enforced using JWT and blue dots indicate locations where credentials need to be securely stored. Secrets within Drasi are stored using the secrets management capabilities provided by Kubernetes. 

The Source Database (red rectangle) to the left of the diagram represents data sources that feed Drasi. The Consumer (orange rectangle) to the right of the diagram represents consumer applications and the messaging infrastructure that exist to receive change notifications from Drasi. These databases, applications, and infrastructure services are outside the control of Drasi.

## Source Custom Resource
A Source provides the Reactive Graph with connectivity to a source system so that it can:
-	query data required to bootstrap a Continuous Query when it is created.
-	process the changes made to the source database and distribute them to the Continuous Queries that require them.

The following diagram shows the services that comprise a Source custom resource.

![Source Services](source-services.png)

These services have the following responsibilities:
-	Reactivator – Process the change log/feed from the source database and generate a change event conformant with the Debezium schema (https://debezium.io). Debezium is an open-source change data capture platform that has adapters for many common data sources. By embracing Debezium as a primary input data format Reactive Graph will be able to use many existing Debezium sources as input without the need to develop custom Reactivators.
-	Change Service – Filter out all changes not required downstream and identify which changes need to be delivered to which Query Container. Transform the Debezium change records to an internal Reactive Graph schema called a SourceChangeEvent (described below). 
-	Change Dispatcher – Deliver the SourceChangeEvent generated by the Change Service to the required Query Containers. Making sure they are delivered in strict order.
-	Source Proxy – Execute queries against the source system to get data that Continuous Queries need to bootstrap their query results at creation time. In the future, Source Proxies will also be used to allow Reactions to perform updates on source databases.
-	Query API – Endpoint through which Continuous Queries subscribe to a Source, specifying which types of data they require and through which they request the initial data they need to bootstrap their query result at creation.

Initially, Reactive Graph focused on graph databases as sources, but has been extended to incorporate relational databases (e.g. PostgreSQL) and other systems (e.g. Kubernetes). Current support for relational sources is constrained to treat table rows as graph nodes with the row values as properties. There is, however, currently no attempt to represent foreign keys or join tables as graph relations, instead relying on a mechanism called Source Joins (described below) to integrate data from relational sources into Continuous Query results.

Note that a significant constraint on the Source is that it must process and dispatch source changes in strict order. There is no opportunity for partitioned or parallel processing of the change feed because downstream Continuous Queries must process changes in the order they occur. Currently, changes are forwarded one at a time, but in the future, it may prove beneficial to batch events before forwarding.

## Query Container
A Query Container hosts a collection of user-defined Continuous Queries. 
The following diagram shows the services that comprise a Query Container custom resource.

![Query Container Services](query-container-services.png)

These services have the following responsibilities:
-	Publish API – Simple HTTP interface through which Source Change Dispatchers deliver changes that need to be processed be the Query Container. The Publish API dispatches these changes to the Change Queue which each Query Actor processes using its own cursor.  
-	Query Host – This is a dapr actor host that hosts multiple Continuous Query Actors.
-	Query Actor – Each Continuous Query Actor represents a single Continuous Query.
-	Element Index – Maintains a time-interval-based historical index of all node and relation versions that are potentially part of the Continuous Query solution subgraph. Only those elements that have the potential to be part of a query solution are stored in the index.
-	Solution Index – Maintains a time-interval-based historical index of all Continuous Query solutions.
-	Result Store – A time-interval-based store of Continuous Query results.
-	Query API – Simple HTTP endpoint through which consumers can request the content of a Continuous Query’s result set. By default the Query API returns the current result, but it is possible for the caller to request the result as it was at any point in time. 

### Change Processing
Central to the functionality of the Reactive Graph is the way Continuous Queries take low-level database change log records (represented as SourceChangeEvents) and determine their impact on the current query result. The following diagram shows the overall process:

![Change Processing](change-processing.png)

This process shows:
1.	Publish API places Source Change Event in Change Queue in the sequence they are provided by the source database Change Log
2.	Continuous Query takes Source Change Event from Change Queue for processing. Source Change Events are processed sequentially, there is no parallel processing of Source Change Events within a single Continuous Query.
3.	Continuous Query process ensures the Source Change Event is relevant to the Continuous Query and if so transforms the Source Change Event into a Query Change Event. This transformation includes extracting relevant features from the changed Element (Node or Relation) contained in the Source Change Event. The Continuous Query process then passes the Query Change Event to a Change Processor component.
4.	Change Processor adds the featurized updated Element to the Element Cache and invokes the Match Pattern Solver providing the Query Change Event (and the featurized updated Element it contains) to serve as the anchor element for the solver.
5.	The Match Pattern Solver finds solutions to the Continuous Query starting with the anchor element and using the content of the Element Cache. It stores successful solutions in the solution cache and passes them to the Solution Processor component.
6.	The Solution Processor component gets solutions that the anchor element was previously part of from the Solution Cache and compares them with the solutions generated by the Match Pattern Solver to determine if the database change caused any Query Result Change. If so it calculates which results where added, updated, and deleted. It stores updates in the Result Store and forwards the updates to the Dispatcher for dispatch to Subscribers and their Reactions via the Result Queue. 


## Reaction Custom Resource
Coming Soon...